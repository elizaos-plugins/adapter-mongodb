{"version":3,"sources":["../src/client.ts","../src/index.ts"],"sourcesContent":["import { MongoClient } from 'mongodb';\nimport {\n    DatabaseAdapter,\n    RAGKnowledgeItem,\n    IDatabaseCacheAdapter,\n    Account,\n    Actor,\n    GoalStatus,\n    Participant,\n    type Goal,\n    type Memory,\n    type Relationship,\n    type UUID, elizaLogger,\n} from \"@elizaos/core\";\nimport { v4 } from \"uuid\";\n\ninterface KnowledgeDocument {\n    id: UUID;\n    agentId: UUID;\n    content: string | {\n        text: string;\n        metadata?: {\n            isShared?: boolean;\n            isMain?: boolean;\n            isChunk?: boolean;\n            originalId?: string;\n            chunkIndex?: number;\n        };\n    };\n    embedding: number[] | null;\n    createdAt: Date | number;\n    isMain: boolean;\n    originalId: string | null;\n    chunkIndex: number | null;\n    isShared: boolean;\n}\n\nclass MongoDBDatabaseAdapter\n    extends DatabaseAdapter<MongoClient>\n    implements IDatabaseCacheAdapter\n{\n    private database: any;\n    private databaseName: string;\n    private hasVectorSearch: boolean;\n    private isConnected: boolean = false;\n    private isVectorSearchIndexComputable: boolean;\n    public db: MongoClient;\n\n    constructor(client: MongoClient, databaseName: string) {\n        super();\n        this.db = client;\n        this.databaseName = databaseName;\n        this.hasVectorSearch = false;\n        this.isConnected = false;\n        this.isVectorSearchIndexComputable = true;\n    }\n\n    private async initializeCollections(): Promise<void> {\n        const collections = [\n            'memories',\n            'participants',\n            'cache',\n            'knowledge',\n            'rooms',\n            'accounts',\n            'goals',\n            'logs',\n            'relationships'\n        ];\n\n        for (const collectionName of collections) {\n            try {\n                await this.database.createCollection(collectionName);\n                console.log(`Collection ${collectionName} created or already exists`);\n            } catch (error) {\n                if ((error as any).code !== 48) { // 48 is \"collection already exists\"\n                    console.error(`Error creating collection ${collectionName}:`, error);\n                }\n            }\n        }\n    }\n\n    private async initializeStandardIndexes(): Promise<void> {\n        const collectionsWithIndexes = [\n            {\n                collectionName: 'memories',\n                indexes: [\n                    { key: { type: 1, roomId: 1, agentId: 1, createdAt: -1 } },\n                    { key: { content: \"text\" }, options: { weights: { content: 10 } } }\n                ]\n            },\n            {\n                collectionName: 'participants',\n                indexes: [\n                    { key: { userId: 1, roomId: 1 }, options: { unique: true } }\n                ]\n            },\n            {\n                collectionName: 'cache',\n                indexes: [\n                    { key: { expiresAt: 1 }, options: { expireAfterSeconds: 0 } }\n                ]\n            },\n            {\n                collectionName: 'knowledge',\n                indexes: [\n                    { key: { agentId: 1 } },\n                    { key: { isShared: 1 } },\n                    { key: { id: 1 }, options: { unique: true } },\n                    { key: { \"content.text\": \"text\" } }\n                ]\n            }\n        ];\n\n        await Promise.all(collectionsWithIndexes.map(async ({ collectionName, indexes }) => {\n            const collection = this.database.collection(collectionName);\n            const existingIndexes = await collection.listIndexes().toArray();\n\n            for (const index of indexes) {\n                const indexExists = existingIndexes.some(existingIndex =>\n                    JSON.stringify(existingIndex.key) === JSON.stringify(index.key)\n                );\n\n                if (!indexExists) {\n                    console.log(`Creating index for ${collectionName}:`, index.key);\n                    await collection.createIndex(index.key, index.options || {});\n                } else {\n                    console.log(`Index already exists for ${collectionName}:`, index.key);\n                }\n            }\n        }));\n    }\n\n    private async initializeVectorSearch(): Promise<void> {\n        try {\n            // Check if vector search is supported\n            const dbStatus = await this.database.admin().serverStatus();\n            const vectorSearchSupported = dbStatus.vectorSearch?.supported === true;\n\n            if (vectorSearchSupported && this.isVectorSearchIndexComputable) {\n                const vectorSearchConfig = {\n                    name: \"vector_index\",\n                    definition: {\n                        vectorSearchConfig: {\n                            dimensions: 1536,\n                            similarity: \"cosine\",\n                            numLists: 100,\n                            efConstruction: 128\n                        }\n                    }\n                };\n\n                try {\n                    // Create vector search indexes for both collections\n                    for (const collection of ['memories', 'knowledge']) {\n                        await this.database.collection(collection).createIndex(\n                            { embedding: \"vectorSearch\" },\n                            vectorSearchConfig\n                        );\n                    }\n\n                    this.hasVectorSearch = true;\n                    console.log(\"Vector search capabilities are available and enabled\");\n\n                    // Check sharding status\n                    const dbInfo = await this.database.admin().command({ listDatabases: 1, nameOnly: true });\n                    const memoriesStats = await this.database.collection('memories').stats();\n\n                    if (dbInfo?.sharded && memoriesStats?.sharded) {\n                        this.isVectorSearchIndexComputable = false;\n                        this.hasVectorSearch = false;\n                        await this.createStandardEmbeddingIndexes();\n                    }\n                } catch (error) {\n                    console.log(\"Vector search initialization failed, falling back to standard search\", error);\n                    this.isVectorSearchIndexComputable = false;\n                    this.hasVectorSearch = false;\n                    await this.createStandardEmbeddingIndexes();\n                }\n            } else {\n                console.log(\"Vector search not supported, using standard search\");\n                this.isVectorSearchIndexComputable = false;\n                this.hasVectorSearch = false;\n                await this.createStandardEmbeddingIndexes();\n            }\n        } catch (error) {\n            console.log(\"Error checking vector search capability, defaulting to standard search\", error);\n            this.isVectorSearchIndexComputable = false;\n            this.hasVectorSearch = false;\n            await this.createStandardEmbeddingIndexes();\n        }\n    }\n\n    private async createStandardEmbeddingIndexes(): Promise<void> {\n        try {\n            for (const collection of ['memories', 'knowledge']) {\n                await this.database.collection(collection).createIndex({ embedding: 1 });\n            }\n            console.log(\"Standard embedding indexes created successfully\");\n        } catch (error) {\n            console.error(\"Failed to create standard embedding indexes:\", error);\n        }\n    }\n\n    async init() {\n        if (this.isConnected) {\n            return;\n        }\n\n        try {\n            await this.db.connect();\n            this.database = this.db.db(this.databaseName);\n\n            await this.initializeCollections();\n            await this.initializeStandardIndexes();\n            await this.initializeVectorSearch();\n\n            try {\n                // Enable sharding for better performance\n                await this.database.command({\n                    enableSharding: this.database.databaseName\n                });\n                await this.database.command({\n                    shardCollection: `${this.database.databaseName}.memories`,\n                    key: { roomId: \"hashed\" }\n                });\n            } catch (error) {\n                console.log(\"Sharding may already be enabled or insufficient permissions\", error);\n            }\n\n            this.isConnected = true;\n\n        } catch (error) {\n            this.isConnected = false;\n            this.isVectorSearchIndexComputable = false;\n            console.error(\"Failed to initialize MongoDB connection:\", error);\n            throw error;\n        }\n    }\n\n    async close() {\n        if (this.isConnected) {\n            await this.db.close();\n            this.isConnected = false;\n        }\n    }\n\n    private async ensureConnection() {\n        if (!this.isConnected) {\n            await this.init();\n        }\n    }\n\n    // Updated database operation methods with connection checks\n    async getRoom(roomId: UUID): Promise<UUID | null> {\n        await this.ensureConnection();\n        const room = await this.database.collection('rooms').findOne({ id: roomId });\n        return room ? room.id : null;\n    }\n\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\n        await this.ensureConnection();\n        return await this.database.collection('participants')\n            .find({ userId })\n            .toArray();\n    }\n\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n        await this.ensureConnection();\n        const participants = await this.database.collection('participants')\n            .find({ roomId })\n            .toArray();\n        return participants.map(p => p.userId);\n    }\n\n    async getParticipantUserState(\n        roomId: UUID,\n        userId: UUID\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\n        await this.ensureConnection();\n        const participant = await this.database.collection('participants')\n            .findOne({ roomId, userId });\n        return participant?.userState ?? null;\n    }\n\n    async setParticipantUserState(\n        roomId: UUID,\n        userId: UUID,\n        state: \"FOLLOWED\" | \"MUTED\" | null\n    ): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('participants').updateOne(\n            { roomId, userId },\n            { $set: { userState: state } }\n        );\n    }\n\n    async getAccountById(userId: UUID): Promise<Account | null> {\n        await this.ensureConnection();\n        const account = await this.database.collection('accounts').findOne({ id: userId });\n        if (!account) return null;\n        return {\n            ...account,\n            details: typeof account.details === 'string' ?\n                JSON.parse(account.details) : account.details\n        };\n    }\n\n    async createAccount(account: Account): Promise<boolean> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('accounts').insertOne({\n                ...account,\n                id: account.id ?? v4(),\n                details: JSON.stringify(account.details),\n                createdAt: new Date()\n            });\n            return true;\n        } catch (error) {\n            console.error(\"Error creating account:\", error);\n            return false;\n        }\n    }\n\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\n        await this.ensureConnection();\n        const actors = await this.database.collection('participants')\n            .aggregate([\n                { $match: { roomId: params.roomId } },\n                {\n                    $lookup: {\n                        from: 'accounts',\n                        localField: 'userId',\n                        foreignField: 'id',\n                        as: 'account'\n                    }\n                },\n                { $unwind: '$account' },\n                {\n                    $project: {\n                        id: '$account.id',\n                        name: '$account.name',\n                        username: '$account.username',\n                        details: '$account.details'\n                    }\n                }\n            ]).toArray();\n\n        return actors\n            .map(actor => ({\n                ...actor,\n                details: typeof actor.details === 'string' ?\n                    JSON.parse(actor.details) : actor.details\n            }))\n            .filter((actor): actor is Actor => actor !== null);\n    }\n\n    async getMemoriesByRoomIds(params: {\n        agentId: UUID;\n        roomIds: UUID[];\n        tableName: string;\n    }): Promise<Memory[]> {\n        await this.ensureConnection();\n        if (!params.tableName) {\n            params.tableName = \"messages\";\n        }\n\n        const memories = await this.database.collection('memories')\n            .find({\n                type: params.tableName,\n                agentId: params.agentId,\n                roomId: { $in: params.roomIds }\n            })\n            .toArray();\n\n        return memories.map(memory => ({\n            ...memory,\n            content: typeof memory.content === 'string' ?\n                JSON.parse(memory.content) : memory.content\n        }));\n    }\n\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\n        await this.ensureConnection();\n        const memory = await this.database.collection('memories').findOne({ id: memoryId });\n        if (!memory) return null;\n\n        return {\n            ...memory,\n            content: typeof memory.content === 'string' ?\n                JSON.parse(memory.content) : memory.content\n        };\n    }\n\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\n\n        await this.ensureConnection();\n        try {\n            let isUnique = true;\n\n            if (memory.embedding) {\n                const similarMemories = await this.searchMemories(\n                    {\n                        tableName,\n                        roomId: memory.roomId,\n                        agentId: memory.agentId,\n                        embedding: memory.embedding,\n                        match_threshold: 0.95,\n                        match_count: 1,\n                        unique: isUnique\n                    }\n                )\n                // const similarMemories = await this.searchMemoriesByEmbedding(\n                //     memory.embedding,\n                //     {\n                //         tableName,\n                //         agentId: memory.agentId,\n                //         roomId: memory.roomId,\n                //         match_threshold: 0.95,\n                //         count: 1\n                //     }\n                // );\n                isUnique = similarMemories.length === 0;\n            }\n\n\n            const content = JSON.stringify(memory.content);\n            const createdAt = memory.createdAt ?? Date.now();\n\n            await this.database.collection('memories').insertOne({\n                id: memory.id ?? v4(),\n                type: tableName,\n                content,\n                embedding: memory.embedding ? Array.from(memory.embedding) : null,\n                userId: memory.userId,\n                roomId: memory.roomId,\n                agentId: memory.agentId,\n                unique: isUnique,\n                createdAt: new Date(createdAt)\n            });\n        }catch (e) {\n            elizaLogger.error(e);\n        }\n    }\n\n    private async searchMemoriesFallback(params: {\n        embedding: number[];\n        query: any;\n        limit?: number;\n    }): Promise<Memory[]> {\n        await this.ensureConnection();\n        // Implement a basic similarity search using standard MongoDB operations\n        const memories = await this.database.collection('memories')\n            .find(params.query)\n            .limit(params.limit || 10)\n            .toArray();\n\n        // Sort by cosine similarity computed in application\n        return memories\n            .map(memory => ({\n                ...memory,\n                similarity: this.cosineSimilarity(params.embedding, memory.embedding)\n            }))\n            .sort((a, b) => b.similarity - a.similarity)\n            .map(memory => ({\n                ...memory,\n                createdAt: typeof memory.createdAt === \"string\" ?\n                    Date.parse(memory.createdAt) : memory.createdAt,\n                content: typeof memory.content === 'string' ?\n                    JSON.parse(memory.content) : memory.content\n            }));\n    }\n\n    private cosineSimilarity(a: Float32Array | number[], b: Float32Array | number[]): number {\n        const aArr = Array.from(a);\n        const bArr = Array.from(b);\n        const dotProduct = aArr.reduce((sum, val, i) => sum + val * bArr[i], 0);\n        const magnitudeA = Math.sqrt(aArr.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(bArr.reduce((sum, val) => sum + val * val, 0));\n        return dotProduct / (magnitudeA * magnitudeB);\n    }\n\n    async searchMemories(params: {\n        tableName: string;\n        roomId: UUID;\n        agentId?: UUID;\n        embedding: number[];\n        match_threshold: number;\n        match_count: number;\n        unique: boolean;\n    }): Promise<Memory[]> {\n        await this.ensureConnection();\n        const query = {\n            type: params.tableName,\n            roomId: params.roomId,\n            ...(params.unique && { unique: true }),\n            ...(params.agentId && { agentId: params.agentId })\n        };\n\n        if (this.hasVectorSearch) {\n            const pipeline = [\n                {\n                    $search: {\n                        vectorSearch: {\n                            queryVector: new Float32Array(params.embedding),\n                            path: \"embedding\",\n                            numCandidates: params.match_count * 2,\n                            limit: params.match_count,\n                            index: \"vector_index\",\n                        }\n                    }\n                },\n                { $match: query }\n            ];\n\n            try {\n                const memories = await this.database.collection('memories')\n                    .aggregate(pipeline)\n                    .toArray();\n\n                return memories.map(memory => ({\n                    ...memory,\n                    createdAt: typeof memory.createdAt === \"string\" ?\n                        Date.parse(memory.createdAt) : memory.createdAt,\n                    content: typeof memory.content === 'string' ?\n                        JSON.parse(memory.content) : memory.content\n                }));\n            } catch (error) {\n                console.log(\"Vector search failed, falling back to standard search\", error);\n                return this.searchMemoriesFallback({\n                    embedding: params.embedding,\n                    query,\n                    limit: params.match_count\n                });\n            }\n        }\n\n        return this.searchMemoriesFallback({\n            embedding: params.embedding,\n            query,\n            limit: params.match_count\n        });\n    }\n\n\n\n    async searchMemoriesByEmbedding(\n        embedding: number[],\n        params: {\n            match_threshold?: number;\n            count?: number;\n            roomId?: UUID;\n            agentId: UUID;\n            unique?: boolean;\n            tableName: string;\n        }\n    ): Promise<Memory[]> {\n        await this.ensureConnection();\n        const pipeline = [\n            {\n                $search: {\n                    vectorSearch: {\n                        queryVector: Array.from(embedding),\n                        path: \"embedding\",\n                        numCandidates: (params.count ?? 10) * 2,\n                        limit: params.count,\n                        index: \"vector_index\"\n                    }\n                }\n            },\n            {\n                $match: {\n                    type: params.tableName,\n                    agentId: params.agentId,\n                    ...(params.unique && { unique: true }),\n                    ...(params.roomId && { roomId: params.roomId })\n                }\n            }\n        ];\n\n        const memories = await this.database.collection('memories')\n            .aggregate(pipeline)\n            .toArray();\n\n        return memories.map(memory => ({\n            ...memory,\n            createdAt: typeof memory.createdAt === \"string\" ?\n                Date.parse(memory.createdAt) : memory.createdAt,\n            content: typeof memory.content === 'string' ?\n                JSON.parse(memory.content) : memory.content\n        }));\n    }\n\n    async getCachedEmbeddings(opts: {\n        query_table_name: string;\n        query_threshold: number;\n        query_input: string;\n        query_field_name: string;\n        query_field_sub_name: string;\n        query_match_count: number;\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\n        await this.ensureConnection();\n        const BATCH_SIZE = 1000; // Process in chunks of 1000 documents\n        let results: { embedding: number[]; levenshtein_score: number }[] = [];\n\n        try {\n            // Get total count for progress tracking\n            const totalCount = await this.database.collection('memories').countDocuments({\n                type: opts.query_table_name,\n                [`content.${opts.query_field_name}.${opts.query_field_sub_name}`]: { $exists: true }\n            });\n\n            let processed = 0;\n\n            while (processed < totalCount) {\n                // Fetch batch of documents\n                const memories = await this.database.collection('memories')\n                    .find({\n                        type: opts.query_table_name,\n                        [`content.${opts.query_field_name}.${opts.query_field_sub_name}`]: { $exists: true }\n                    })\n                    .skip(processed)\n                    .limit(BATCH_SIZE)\n                    .toArray();\n\n                // Process batch\n                const batchResults = memories\n                    .map(memory => {\n                        try {\n                            const content = memory.content[opts.query_field_name][opts.query_field_sub_name];\n                            if (!content || typeof content !== 'string') {\n                                return null;\n                            }\n\n                            return {\n                                embedding: Array.from(memory.embedding),\n                                levenshtein_score: this.calculateLevenshteinDistanceOptimized(\n                                    content.toLowerCase(),\n                                    opts.query_input.toLowerCase()\n                                )\n                            };\n                        } catch (error) {\n                            console.warn(`Error processing memory document: ${error}`);\n                            return null;\n                        }\n                    })\n                    .filter((result): result is { embedding: number[]; levenshtein_score: number } =>\n                        result !== null);\n\n                // Merge batch results\n                results = this.mergeAndSortResults(results, batchResults, opts.query_match_count);\n                processed += memories.length;\n\n                // Log progress for long operations\n                if (totalCount > BATCH_SIZE) {\n                    console.log(`Processed ${processed}/${totalCount} documents`);\n                }\n            }\n\n            return results;\n\n        } catch (error) {\n            console.error(\"Error in getCachedEmbeddings:\", error);\n            if (results.length > 0) {\n                console.log(\"Returning partial results\");\n                return results;\n            }\n            return [];\n        }\n    }\n\n    /**\n     * Optimized Levenshtein distance calculation with early termination\n     * and matrix reuse for better performance\n     */\n    private calculateLevenshteinDistanceOptimized(str1: string, str2: string): number {\n        // Early termination for identical strings\n        if (str1 === str2) return 0;\n\n        // Early termination for empty strings\n        if (str1.length === 0) return str2.length;\n        if (str2.length === 0) return str1.length;\n\n        // Use shorter string as inner loop for better performance\n        if (str1.length > str2.length) {\n            [str1, str2] = [str2, str1];\n        }\n\n        // Reuse matrix to avoid garbage collection\n        const matrix = this.getLevenshteinMatrix(str1.length + 1, str2.length + 1);\n\n        // Initialize first row and column\n        for (let i = 0; i <= str1.length; i++) matrix[i][0] = i;\n        for (let j = 0; j <= str2.length; j++) matrix[0][j] = j;\n\n        // Calculate minimum edit distance\n        for (let i = 1; i <= str1.length; i++) {\n            for (let j = 1; j <= str2.length; j++) {\n                if (str1[i-1] === str2[j-1]) {\n                    matrix[i][j] = matrix[i-1][j-1];\n                } else {\n                    matrix[i][j] = Math.min(\n                        matrix[i-1][j-1] + 1,  // substitution\n                        matrix[i][j-1] + 1,    // insertion\n                        matrix[i-1][j] + 1     // deletion\n                    );\n                }\n            }\n        }\n\n        return matrix[str1.length][str2.length];\n    }\n\n// Cache for reusing Levenshtein distance matrix\n    private levenshteinMatrix: number[][] = [];\n    private maxMatrixSize = 0;\n\n    private getLevenshteinMatrix(rows: number, cols: number): number[][] {\n        const size = rows * cols;\n        if (size > this.maxMatrixSize) {\n            this.levenshteinMatrix = Array(rows).fill(null)\n                .map(() => Array(cols).fill(0));\n            this.maxMatrixSize = size;\n        }\n        return this.levenshteinMatrix;\n    }\n\n    /**\n     * Efficiently merge and sort two arrays of results while maintaining top K items\n     */\n    private mergeAndSortResults(\n        existing: { embedding: number[]; levenshtein_score: number }[],\n        newResults: { embedding: number[]; levenshtein_score: number }[],\n        limit: number\n    ): { embedding: number[]; levenshtein_score: number }[] {\n        const merged = [...existing, ...newResults];\n\n        // Use quick select algorithm if array is large\n        if (merged.length > 1000) {\n            return this.quickSelectTopK(merged, limit);\n        }\n\n        // Use simple sort for smaller arrays\n        return merged\n            .sort((a, b) => a.levenshtein_score - b.levenshtein_score)\n            .slice(0, limit);\n    }\n\n    /**\n     * Quick select algorithm to efficiently find top K items\n     */\n    private quickSelectTopK(\n        arr: { embedding: number[]; levenshtein_score: number }[],\n        k: number\n    ): { embedding: number[]; levenshtein_score: number }[] {\n        if (arr.length <= k) return arr.sort((a, b) => a.levenshtein_score - b.levenshtein_score);\n\n        const pivot = arr[Math.floor(Math.random() * arr.length)].levenshtein_score;\n        const left = arr.filter(x => x.levenshtein_score < pivot);\n        const equal = arr.filter(x => x.levenshtein_score === pivot);\n        const right = arr.filter(x => x.levenshtein_score > pivot);\n\n        if (k <= left.length) {\n            return this.quickSelectTopK(left, k);\n        }\n        if (k <= left.length + equal.length) {\n            return [...left, ...equal.slice(0, k - left.length)]\n                .sort((a, b) => a.levenshtein_score - b.levenshtein_score);\n        }\n        return [...left, ...equal, ...this.quickSelectTopK(right, k - left.length - equal.length)]\n            .sort((a, b) => a.levenshtein_score - b.levenshtein_score);\n    }\n\n    async updateGoalStatus(params: {\n        goalId: UUID;\n        status: GoalStatus;\n    }): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('goals').updateOne(\n            { id: params.goalId },\n            { $set: { status: params.status } }\n        );\n    }\n\n    async log(params: {\n        body: { [key: string]: unknown };\n        userId: UUID;\n        roomId: UUID;\n        type: string;\n    }): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('logs').insertOne({\n            id: v4(),\n            body: JSON.stringify(params.body),\n            userId: params.userId,\n            roomId: params.roomId,\n            type: params.type,\n            createdAt: new Date()\n        });\n    }\n\n    async getMemories(params: {\n        roomId: UUID;\n        count?: number;\n        unique?: boolean;\n        tableName: string;\n        agentId: UUID;\n        start?: number;\n        end?: number;\n    }): Promise<Memory[]> {\n        await this.ensureConnection();\n        if (!params.tableName) {\n            throw new Error(\"tableName is required\");\n        }\n        if (!params.roomId) {\n            throw new Error(\"roomId is required\");\n        }\n\n        const query: any = {\n            type: params.tableName,\n            agentId: params.agentId,\n            roomId: params.roomId\n        };\n\n        if (params.unique) {\n            query.unique = true;\n        }\n\n        if (params.start || params.end) {\n            query.createdAt = {};\n            if (params.start) query.createdAt.$gte = new Date(params.start);\n            if (params.end) query.createdAt.$lte = new Date(params.end);\n        }\n\n        const memories = await this.database.collection('memories')\n            .find(query)\n            .sort({ createdAt: -1 })\n            .limit(params.count || 0)\n            .toArray();\n\n        return memories.map(memory => ({\n            ...memory,\n            createdAt: new Date(memory.createdAt).getTime(),\n            content: typeof memory.content === 'string' ?\n                JSON.parse(memory.content) : memory.content\n        }));\n    }\n\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('memories').deleteOne({\n            id: memoryId,\n            type: tableName\n        });\n    }\n\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('memories').deleteMany({\n            roomId,\n            type: tableName\n        });\n    }\n\n    async countMemories(\n        roomId: UUID,\n        unique = true,\n        tableName = \"\"\n    ): Promise<number> {\n        await this.ensureConnection();\n        if (!tableName) {\n            throw new Error(\"tableName is required\");\n        }\n\n        const query: any = {\n            type: tableName,\n            roomId\n        };\n\n        if (unique) {\n            query.unique = true;\n        }\n\n        return await this.database.collection('memories').countDocuments(query);\n    }\n\n    async getGoals(params: {\n        roomId: UUID;\n        userId?: UUID | null;\n        onlyInProgress?: boolean;\n        count?: number;\n    }): Promise<Goal[]> {\n        await this.ensureConnection();\n        const query: any = { roomId: params.roomId };\n\n        if (params.userId) {\n            query.userId = params.userId;\n        }\n\n        if (params.onlyInProgress) {\n            query.status = 'IN_PROGRESS';\n        }\n\n        const goals = await this.database.collection('goals')\n            .find(query)\n            .limit(params.count || 0)\n            .toArray();\n\n        return goals.map(goal => ({\n            ...goal,\n            objectives: typeof goal.objectives === 'string' ?\n                JSON.parse(goal.objectives) : goal.objectives\n        }));\n    }\n\n    async updateGoal(goal: Goal): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('goals').updateOne(\n            { id: goal.id },\n            {\n                $set: {\n                    name: goal.name,\n                    status: goal.status,\n                    objectives: JSON.stringify(goal.objectives)\n                }\n            }\n        );\n    }\n\n    async createGoal(goal: Goal): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('goals').insertOne({\n            ...goal,\n            id: goal.id ?? v4(),\n            objectives: JSON.stringify(goal.objectives),\n            createdAt: new Date()\n        });\n    }\n\n    async removeGoal(goalId: UUID): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('goals').deleteOne({ id: goalId });\n    }\n\n    async removeAllGoals(roomId: UUID): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('goals').deleteMany({ roomId });\n    }\n\n    async createRoom(roomId?: UUID): Promise<UUID> {\n        await this.ensureConnection();\n        const newRoomId = roomId || v4() as UUID;\n        try {\n            await this.database.collection('rooms').insertOne({\n                id: newRoomId,\n                createdAt: new Date()\n            });\n            return newRoomId;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error; // Throw error instead of silently continuing\n        }\n    }\n\n    async removeRoom(roomId: UUID): Promise<void> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('rooms').deleteOne({ id: roomId });\n        } catch (error) {\n            console.error(\"Error removing room:\", error);\n            throw error;\n        }\n    }\n\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\n        await this.ensureConnection();\n        const rooms = await this.database.collection('participants')\n            .find({ userId })\n            .project({ roomId: 1 })\n            .toArray();\n        return rooms.map(r => r.roomId);\n    }\n\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\n        await this.ensureConnection();\n        const rooms = await this.database.collection('participants')\n            .distinct('roomId', { userId: { $in: userIds } });\n        return rooms;\n    }\n\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('participants').insertOne({\n                id: v4(),\n                userId,\n                roomId,\n                createdAt: new Date()\n            });\n            return true;\n        } catch (error) {\n            console.log(\"Error adding participant\", error);\n            return false;\n        }\n    }\n\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('participants').deleteOne({\n                userId,\n                roomId\n            });\n            return true;\n        } catch (error) {\n            console.log(\"Error removing participant\", error);\n            return false;\n        }\n    }\n\n    async createRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<boolean> {\n        await this.ensureConnection();\n        if (!params.userA || !params.userB) {\n            throw new Error(\"userA and userB are required\");\n        }\n\n        try {\n            await this.database.collection('relationships').insertOne({\n                id: v4(),\n                userA: params.userA,\n                userB: params.userB,\n                userId: params.userA,\n                createdAt: new Date()\n            });\n            return true;\n        } catch (error) {\n            console.log(\"Error creating relationship\", error);\n            return false;\n        }\n    }\n\n    async getRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<Relationship | null> {\n        await this.ensureConnection();\n        return await this.database.collection('relationships').findOne({\n            $or: [\n                { userA: params.userA, userB: params.userB },\n                { userA: params.userB, userB: params.userA }\n            ]\n        });\n    }\n\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\n        await this.ensureConnection();\n        return await this.database.collection('relationships')\n            .find({\n                $or: [\n                    { userA: params.userId },\n                    { userB: params.userId }\n                ]\n            })\n            .toArray();\n    }\n\n    async getCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<string | undefined> {\n        await this.ensureConnection();\n        const cached = await this.database.collection('cache')\n            .findOne({\n                key: params.key,\n                agentId: params.agentId,\n                expiresAt: { $gt: new Date() }\n            });\n        return cached?.value;\n    }\n\n    async setCache(params: {\n        key: string;\n        agentId: UUID;\n        value: string;\n    }): Promise<boolean> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('cache').updateOne(\n                { key: params.key, agentId: params.agentId },\n                {\n                    $set: {\n                        value: params.value,\n                        createdAt: new Date(),\n                        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours expiry\n                    }\n                },\n                { upsert: true }\n            );\n            return true;\n        } catch (error) {\n            console.log(\"Error setting cache\", error);\n            return false;\n        }\n    }\n\n    async deleteCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<boolean> {\n        await this.ensureConnection();\n        try {\n            await this.database.collection('cache').deleteOne({\n                key: params.key,\n                agentId: params.agentId\n            });\n            return true;\n        } catch (error) {\n            console.log(\"Error removing cache\", error);\n            return false;\n        }\n    }\n\n    async getKnowledge(params: {\n        id?: UUID;\n        agentId: UUID;\n        limit?: number;\n        query?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        await this.ensureConnection();\n\n        const query: any = {\n            $or: [\n                { agentId: params.agentId },\n                { isShared: true }\n            ]\n        };\n\n        if (params.id) {\n            query.id = params.id;\n        }\n\n        const knowledge = await this.database.collection('knowledge')\n            .find(query)\n            .limit(params.limit || 0)\n            .toArray();\n\n        return knowledge.map(item => ({\n            id: item.id,\n            agentId: item.agentId,\n            content: typeof item.content === 'string' ? JSON.parse(item.content) : item.content,\n            embedding: item.embedding ? new Float32Array(item.embedding) : undefined,\n            createdAt: typeof item.createdAt === \"string\" ? Date.parse(item.createdAt) : item.createdAt\n        }));\n    }\n\n    async searchKnowledge(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        match_count: number;\n        searchText?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        await this.ensureConnection();\n\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\n        const cachedResult = await this.getCache({\n            key: cacheKey,\n            agentId: params.agentId\n        });\n\n        if (cachedResult) {\n            return JSON.parse(cachedResult);\n        }\n\n        try {\n            let results: KnowledgeDocument[];\n\n            if (this.hasVectorSearch) {\n                try {\n                    results = await this.vectorSearchKnowledge(params);\n                } catch (error) {\n                    console.log(\"Vector search failed, falling back to standard search\", error);\n                    results = await this.fallbackSearchKnowledge(params);\n                }\n            } else {\n                results = await this.fallbackSearchKnowledge(params);\n            }\n\n            const mappedResults = results.map(item => ({\n                id: item.id,\n                agentId: item.agentId, // This will always be UUID\n                content: typeof item.content === 'string' ? JSON.parse(item.content) : item.content,\n                embedding: item.embedding ? new Float32Array(item.embedding) : undefined,\n                createdAt: typeof item.createdAt === \"string\" ? Date.parse(item.createdAt) : item.createdAt,\n                similarity: (item as any).combinedScore || 0\n            })) as RAGKnowledgeItem[];\n\n            await this.setCache({\n                key: cacheKey,\n                agentId: params.agentId,\n                value: JSON.stringify(mappedResults)\n            });\n\n            return mappedResults;\n        } catch (error) {\n            console.error(\"Error in searchKnowledge:\", error);\n            throw error;\n        }\n    }\n\n    private async vectorSearchKnowledge(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        match_count: number;\n        searchText?: string;\n    }): Promise<KnowledgeDocument[]> {\n        const pipeline = [\n            {\n                $search: {\n                    vectorSearch: {\n                        queryVector: Array.from(params.embedding),\n                        path: \"embedding\",\n                        numCandidates: params.match_count * 2,\n                        limit: params.match_count * 2,\n                        index: \"vector_index\"\n                    }\n                }\n            },\n            ...this.getKnowledgeSearchPipeline(params)\n        ];\n\n        return await this.database.collection('knowledge')\n            .aggregate(pipeline)\n            .toArray();\n    }\n\n    private async fallbackSearchKnowledge(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        match_count: number;\n        searchText?: string;\n    }): Promise<KnowledgeDocument[]> {\n        const pipeline = [\n            {\n                $match: {\n                    $or: [\n                        { agentId: params.agentId },\n                        { isShared: true, agentId: null }\n                    ]\n                }\n            },\n            ...this.getKnowledgeSearchPipeline(params)\n        ];\n\n        return await this.database.collection('knowledge')\n            .aggregate(pipeline)\n            .toArray();\n    }\n\n    private getKnowledgeSearchPipeline(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        searchText?: string;\n    }): object[] {\n        return [\n            {\n                $addFields: {\n                    vectorScore: this.hasVectorSearch ?\n                        { $meta: \"vectorSearchScore\" } :\n                        {\n                            $let: {\n                                vars: {\n                                    embedding: { $ifNull: [\"$embedding\", []] }\n                                },\n                                in: {\n                                    $cond: [\n                                        { $eq: [{ $size: \"$$embedding\" }, 0] },\n                                        0,\n                                        {\n                                            $divide: [\n                                                1,\n                                                { $add: [1, { $function: {\n                                                            body: this.cosineSimilarity.toString(),\n                                                            args: [params.embedding, \"$$embedding\"],\n                                                            lang: \"js\"\n                                                        }}] }\n                                            ]\n                                        }\n                                    ]\n                                }\n                            }\n                        },\n                    keywordScore: this.calculateKeywordScore(params.searchText)\n                }\n            },\n            {\n                $addFields: {\n                    combinedScore: { $multiply: [\"$vectorScore\", \"$keywordScore\"] }\n                }\n            },\n            {\n                $match: {\n                    $or: [\n                        { vectorScore: { $gte: params.match_threshold } },\n                        {\n                            $and: [\n                                { keywordScore: { $gt: 1.0 } },\n                                { vectorScore: { $gte: 0.3 } }\n                            ]\n                        }\n                    ]\n                }\n            },\n            { $sort: { combinedScore: -1 } }\n        ];\n    }\n\n    private calculateKeywordScore(searchText?: string): object {\n        return {\n            $multiply: [\n                {\n                    $cond: [\n                        searchText ? {\n                            $regexMatch: {\n                                input: { $toLower: \"$content.text\" },\n                                regex: new RegExp(searchText.toLowerCase())\n                            }\n                        } : false,\n                        3.0,\n                        1.0\n                    ]\n                },\n                {\n                    $cond: [\n                        { $eq: [\"$content.metadata.isChunk\", true] },\n                        1.5,\n                        {\n                            $cond: [\n                                { $eq: [\"$content.metadata.isMain\", true] },\n                                1.2,\n                                1.0\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n    }\n\n    // Update error handling in createKnowledge\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\n        await this.ensureConnection();\n\n        try {\n            const metadata = knowledge.content.metadata || {};\n            const isShared = metadata.isShared || false;\n\n            const doc = {\n                id: knowledge.id,\n                agentId: knowledge.agentId,\n                content: typeof knowledge.content === 'string' ?\n                    knowledge.content :\n                    JSON.stringify(knowledge.content),\n                embedding: knowledge.embedding ? Array.from(knowledge.embedding) : null,\n                createdAt: knowledge.createdAt || Date.now(),\n                isMain: metadata.isMain || false,\n                originalId: metadata.originalId || null,\n                chunkIndex: metadata.chunkIndex || null,\n                isShared\n            };\n\n            await this.database.collection('knowledge').updateOne(\n                { id: knowledge.id },\n                { $setOnInsert: doc },\n                { upsert: true }\n            );\n        } catch (err) {\n            if (err instanceof Error) {\n                const error = err as Error & { code?: number };\n                const isShared = knowledge.content.metadata?.isShared;\n\n                if (isShared && error.code === 11000) {\n                    console.info(`Shared knowledge ${knowledge.id} already exists, skipping`);\n                    return;\n                }\n\n                console.error(`Error creating knowledge ${knowledge.id}:`, error);\n                throw error;\n            }\n            throw err;\n        }\n    }\n\n    async removeKnowledge(id: UUID): Promise<void> {\n        await this.ensureConnection();\n        await this.database.collection('knowledge').deleteOne({ id });\n    }\n\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\n        await this.ensureConnection();\n        const query = shared ?\n            { $or: [{ agentId }, { isShared: true }] } :\n            { agentId };\n\n        try {\n            await this.database.collection('knowledge').deleteMany(query);\n        } catch (error) {\n            console.error(`Error clearing knowledge for agent ${agentId}:`, error);\n            throw error;\n        }\n    }\n\n    async getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]> {\n        await this.ensureConnection();\n        const collection = tableName || 'memories';\n\n        try {\n            const memories = await this.database.collection(collection)\n                .find({ id: { $in: memoryIds } })\n                .toArray();\n\n            return memories.map(memory => ({\n                id: memory.id,\n                roomId: memory.roomId,\n                agentId: memory.agentId,\n                type: memory.type,\n                content: memory.content,\n                embedding: memory.embedding,\n                createdAt: memory.createdAt instanceof Date ? memory.createdAt.getTime() : memory.createdAt,\n                metadata: memory.metadata || {}\n            }));\n        } catch (error) {\n            elizaLogger.error('Failed to get memories by IDs:', error);\n            return [];\n        }\n    }\n\n}\n\nexport const mongoDBAdapter: Adapter = {\n    init: (runtime: IAgentRuntime) => {\n        const MONGODB_CONNECTION_STRING = runtime.getSetting(\"MONGODB_CONNECTION_STRING\");\n        if (MONGODB_CONNECTION_STRING) {\n            elizaLogger.log(\"Initializing database on MongoDB Atlas\");\n            const client = new MongoClient(MONGODB_CONNECTION_STRING, {\n                maxPoolSize: 100,\n                minPoolSize: 5,\n                maxIdleTimeMS: 60000,\n                connectTimeoutMS: 10000,\n                serverSelectionTimeoutMS: 5000,\n                socketTimeoutMS: 45000,\n                compressors: [\"zlib\"],\n                retryWrites: true,\n                retryReads: true,\n            });\n    \n            const dbName = runtime.getSetting(\"MONGODB_DATABASE\") || \"elizaAgent\";\n            const db = new MongoDBDatabaseAdapter(client, dbName);\n    \n            // Test the connection\n            db.init()\n                .then(() => {\n                    elizaLogger.success(\"Successfully connected to MongoDB Atlas\");\n                })\n                .catch((error) => {\n                    elizaLogger.error(\"Failed to connect to MongoDB Atlas:\", error);\n                    throw error; // Re-throw to handle it in the calling code\n                });\n    \n            return db;\n        } else {\n            throw new Error(\"MONGODB_CONNECTION_STRING is not set\");\n        }\n    },\n};","import { mongoDBAdapter } from './client';\n\nconst mongodbPlugin = {\n    name: \"mongodb\",\n    description: \"MongoDB database adapter plugin\",\n    adapters: [mongoDBAdapter],\n};\nexport default mongodbPlugin;"],"mappings":"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","names":[]}